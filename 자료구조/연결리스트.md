# 연결리스트

복습: 이해완료

리스트? 항목들을 차례대로 저장한 것

구현 → 배열, 포인터를 이용한 연결 리스트

---

**배열로 구현된 리스트**

순차적인 메모리 공간이 할당되므로 리스트의 순차적 표현이라고 함

- 구현 간단, 속도 빠름
- 크기가 고정됨 (공간 없으면 문제 발생, 중간에 삽입 및 삭제할 때 기존 데이터 이동해야 함)

```c
#define MAX_LIST_SIZE 10
struct ArrayListType {
	int array[MAX_LIST_SIZE]; //리스트로 사용할 배열 정의
	int size;  // 현재 리스트에 저장된 항목들의 개수
};
```

### **연결 리스트**

**포인터를 사용하여 데이터 연결**

메모리상 흩어져 있는 데이터를 연결하여 하나로 묶음

- 데이터 이동할 필요 없이 포인터만 변경하면 됨
- 상대적으로 구현 어려움, 메모리 공간 차지
- 데이터 탐색하기 위해서 순차적으로 접근해야 함
- 동적메모리 할당 → 데이터 저장 공간이 필요할 때마다 동적으로 공간을 만들어 사용

![그림6-6.JPG.jpg](%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%AF%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%207a70b5532aa24d97a8ae4c7b6c479917/%25EA%25B7%25B8%25EB%25A6%25BC6-6.JPG.jpg)

`데이터 필드(저장하고 싶은 데이터)` 

`링크 필드(다른 노드 가리키는 포인터)`  

**헤드 포인터(head pointer) : 첫 번째 노드를 가리키고 있는 변수**

**마지막 노드 링크 필드는 NULL로 설정** (연결 노드 X)

노드는 필요할 때마다 **malloc()을 이용해 동적으로 생성**

---

![그림6-8.JPG.jpg](%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%AF%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%207a70b5532aa24d97a8ae4c7b6c479917/%25EA%25B7%25B8%25EB%25A6%25BC6-8.JPG.jpg)

`노드 ⇒ 자기 참조 구조체 이용`

`자기 참조 구조체? 자기 자신을 참조하는 포인터를 포함하는 구조체`